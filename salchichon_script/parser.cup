package salchichon_script;

import java_cup.runtime.Symbol;

// PARSER
parser code
{:

    // Errores recuperables
    public void syntax_error(Symbol s){
        System.out.println("Error R de sintaxis: "+ s.value +" Línea "+(s.left+1)+" Columna "+(s.right+1) );
    }

    // Errores no recuperables
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception { 
        System.out.println("Error NR de sintaxis: " + s.value + " Línea " + (s.left+1) + " Columna " + (s.right+1));
    }
:}

action code
{:
    // Codigo de usuario - fase de analisis
    String tmp="";
:}

// TERMINALES
terminal PAR_A, PAR_C, BLO_A, BLO_C, COMA, FLECHA, FIN_E, ASIGN;
terminal MAS, MENOS, POR, DIV, DIV_ENT, MOD, POT;
terminal AND, OR, NOT;
terminal INC, DEC;
terminal MAYOR, MENOR, MAY_IGU, MEN_IGU, IGUAL, DIF;
terminal INT1, CHAR1, STR1, FLOAT1, BOOL1, LET, VOID, TRUE1, FALSE1, DECIDE;
terminal OF, ELSE, END, LOOP, EXIT, WHEN, FOR1, STEP, TO, DOWNTO, DO;
terminal RETURN, BREAK;
terminal OUTPUT, INPUT, INIT;

terminal ENTERO, DECIMALES, FLOTANTE, CHAR, ID, SPACE, ENTER, FIN_L, INPUT1, COM_S, COM_C, COMENTARIO;
terminal IMPRIMIR, LEER, MAIN, CADENA;

// NO TERMINALES
non terminal Object program;
non terminal main_funcion, elemento_global, lista_global;
non terminal tipo, tipo_funcion, declaracion;
non terminal bloque, lista_sentencias, lista_sentencias_opt, sentencia, expr_opc, llamada_funcion, imprimir, leer;
non terminal funcion, parametros_opt, lista_parametros, parametro;
non terminal asignacion, asignacion_dec;
non terminal expresion;
non terminal expresion_arit, termino, factor, potencia, operando, elem_arr;
non terminal op_rel, incrementar, decrementar;
non terminal condicional, lista_casos, caso, cond_else_opt, bucle_loop, bucle_for, step, direccion;

// PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left IGUAL, DIF;
precedence left MAYOR, MENOR, MAY_IGU, MEN_IGU;
precedence left MAS, MENOS;
precedence left POR, DIV, DIV_ENT, MOD;
precedence right POT;
precedence right NOT;

// PRODUCCIONES

start with program;


program ::= lista_global main_funcion lista_global
    ;
    
lista_global ::= elemento_global lista_global
    | /* vacío */
    ;

elemento_global ::= sentencia
    | funcion
    ;

main_funcion ::= INIT VOID MAIN PAR_A PAR_C bloque FIN_E
    | INIT VOID MAIN bloque FIN_E
    ;


// ======== DECLARACIÓN DE VARIABLES ========
tipo ::= INT1
    | STR1
    | FLOAT1
    | BOOL1
    | CHAR1
    ;

tipo_funcion ::= tipo
    | VOID
    ;

//+++++++++++++++++++++BLOQUE++++++++++++++++++++++++++++++++++

bloque ::= BLO_A lista_sentencias_opt BLO_C;

lista_sentencias_opt ::= /* vacío */
                     | lista_sentencias
                     ;

lista_sentencias ::= sentencia
                  | lista_sentencias sentencia
                  ;
sentencia ::= declaracion FIN_E //AQUI DECLARAMOS QUE LAS SENTENCIAS SON TODOS AQUELLOS ELEMENTOS QUE SE PUEDEN UTILIZAR PARA GENERAR ALGUNA ESTRUCTURA CON SENTIDO
    | asignacion FIN_E
    | llamada_funcion FIN_E
    | imprimir FIN_E
    | leer FIN_E
    | RETURN expr_opc FIN_E
    | BREAK FIN_E
    | incrementar FIN_E
    | decrementar FIN_E
    | condicional FIN_E
    | bucle_loop 
    | bucle_for
    ;

incrementar ::= ID INC;
decrementar ::= ID DEC;

expr_opc ::=
      expresion
    | /* ε */
    ;


llamada_funcion ::= ID PAR_A parametros_opt PAR_C;

imprimir ::= IMPRIMIR PAR_A expresion PAR_C;
leer ::= LEER PAR_A PAR_C | LEER PAR_A PAR_C ASIGN ID;

//+++++++++++++++++++++FUNCIONES++++++++++++++++++++++++++++++++

funcion ::= tipo_funcion ID PAR_A parametros_opt PAR_C bloque FIN_E;

parametros_opt ::= lista_parametros
                 | // VACIO
                 ;

lista_parametros ::= parametro //LISTA DE PARAMETROS ES UN PARAMETRO O LISTA DE PARAMETROS SEGUIDO DE UNA COMA Y UN PARAMETRO
                  | lista_parametros COMA parametro
                  ;

parametro ::= tipo ID; //UN PARAMETRO ES UN TIPO SEGUIDO DE UN ID
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

declaracion ::= LET tipo ID asignacion_dec
    ;

// ASIGNACION DE VARIABLES
asignacion_dec ::= ASIGN expresion 
    | /* ε */
    ;

asignacion ::= ID ASIGN expresion// UNA ASIGNACION SENCILLA
    ;

// EXPRESIONES
expresion ::= expresion AND expresion //AQUI CONTEMPLAMOS LAS OPERACIONES LOGICAS
    | expresion OR expresion
    | NOT expresion
    | expresion_arit op_rel expresion_arit
    | expresion_arit
    ;


// EXPRESIONES ARITMETICAS
expresion_arit ::= expresion_arit MAS termino //UNA EXPRESIÓN ARITMETICA ES LA SUMA DE UNA EXPRESION ARITMETICA Y UN TERMINO O LA RESTA DE ESTOS O PUEDE SER UN PRODUCTO
    | expresion_arit MENOS termino //SE HACE DE ESTA FORMA PARA PODER MANTENER EL ORDE DE LAS OPERACIONES
    | termino
    ;

termino ::= factor POR factor //UN TERMINO PUEDE SER UN FACTOR POR UN FACTOR O DIVICION ENTERA O MODULO, DE ESTA FORMA RESOLVEMOS PRIMERO LAS DE MÁS IMPORTANCIA
    | factor DIV factor
    | factor DIV_ENT factor
    | factor MOD factor
    | factor
    ;

factor ::= potencia POT potencia //AQUI USAMOS RECURSIVIDAD Y DECIMOS QUE UN FACTOR PUEDE SER UNA POTENCIA Y A SU VEZ UNA POTENCIA PUEDE SER UN OPERANDO O PUEDE SER UNA POTENCIA A LA POTENCIA QUE TERMINA SIENDO UN OPERANDO
    | potencia
    ;

potencia ::= PAR_A expresion PAR_C //UNA POTENCIA PUEDE SER UNA EXPRESION DENTRO DE PARENTESIS O UN OPERANDO
    | operando
    ;
//UN OPERANDO ES LA FORMA MÁS SENCILLA DE UNA OPERACIÓN
operando ::= ENTERO
    | FLOTANTE
    | TRUE1
    | FALSE1
    | CHAR
    | CADENA
    | ID 
    | llamada_funcion
    | elem_arr
    | MENOS operando
    | incrementar
    | decrementar
    ;

// OPERADORES RELACIONALES
op_rel ::= MAYOR
    | MENOR
    | MAY_IGU
    | MEN_IGU
    | IGUAL
    | DIF
    ;

// ESTRUCTURAS DE CONTROL

condicional ::= DECIDE OF lista_casos cond_else_opt END DECIDE; //PRODUCCION DE CONDICIONAL DONDE RECIBE UNA LISTA DE CASOS UN ELSE CONDICIONAL Y EL END DECIDE

lista_casos ::= caso
              | caso lista_casos // SE PUEDE UN SOLO CASO O UNA LISTA DE CASOS
              ;

caso ::= PAR_A expresion PAR_C FLECHA bloque; //LOS CASOS QUE PUEDEN ESTAR EN LA CONDICIONAL

cond_else_opt ::= /* vacío */
                 | ELSE FLECHA bloque // PODEMOS PONER ELSE O PODEMOS DEJARLO VACIO
                 ;

bucle_loop ::= LOOP lista_sentencias EXIT WHEN expresion FIN_E END LOOP FIN_E; //EL BUCLE LOOP ESTÁ HECHO DE LA PALABRA RESERVADA LOOP SEGUIDO DE LA LISTA DE SENTENCIAS, EXIT WHEN, LA EXPRESION FINAL, Y EXIT LOOP SEGUIDO DEL FINAL DE EXPRESION

bucle_for ::= FOR1 PAR_A asignacion PAR_C step direccion expresion DO bloque END FOR1 FIN_E; //UN BUCLE FOR ESTA HECHO DE PALABRA RESERVADA FOR, PARENTESIS, LA ASIGNACION, PARENTESIS, STEP, LA DIRECCION DEL CONTADOR, A EXPRESION Y LA EL BLOQUE


step ::= /* vacío */ 
       | STEP //PALABRA RESERVADA STEP QUE SE NOS SOLICITA AGREGAR EN LA GRAMATICA
       ;

direccion ::= TO //DIRECCIÓN EN LA QUE VA A CORRER EL CONTADOR
            | DOWNTO
            ;





